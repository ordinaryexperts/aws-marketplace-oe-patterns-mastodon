import os

from aws_cdk import (
    Arn,
    ArnComponents,
    Aws,
    aws_ec2,
    aws_iam,
    aws_lambda,
    aws_route53,
    aws_s3,
    aws_ses,
    CfnCondition,
    CfnDeletionPolicy,
    CfnMapping,
    CfnOutput,
    CfnParameter,
    CustomResource,
    Fn,
    Stack,
    Token
)
from constructs import Construct

from oe_patterns_cdk_common.alb import Alb
from oe_patterns_cdk_common.asg import Asg
from oe_patterns_cdk_common.aurora_cluster import AuroraPostgresql
from oe_patterns_cdk_common.db_secret import DbSecret
from oe_patterns_cdk_common.dns import Dns
from oe_patterns_cdk_common.elasticache_cluster import ElasticacheRedis
from oe_patterns_cdk_common.ses import Ses
from oe_patterns_cdk_common.vpc import Vpc

# AMI list generated by ami-ec2-build
AMI_ID="ami-03b329136d64923bd"
AMI_NAME="ordinary-experts-patterns-mastodon--20221025-0434"
generated_ami_ids = {
    "us-east-1": "ami-03b329136d64923bd"
}
# End generated code block.

class MastodonStack(Stack):

    def __init__(self, scope: Construct, construct_id: str, **kwargs) -> None:
        super().__init__(scope, construct_id, **kwargs)

        # vpc
        vpc = Vpc(
            self,
            "Vpc"
        )

        self.name_param = CfnParameter(
            self,
            "Name",
            default="Mastodon",
            description="The name of this Mastodon site."
        )
        self.name_param.override_logical_id("Name")
        self.assets_bucket_name_param = CfnParameter(
            self,
            "AssetsBucketName",
            default="",
            description="The name of the S3 bucket to store uploaded assets. If not specified, a bucket will be created."
        )
        self.assets_bucket_name_param.override_logical_id("AssetsBucketName")

        self.assets_bucket_name_not_exists_condition = CfnCondition(
            self,
            "AssetsBucketNameNotExists",
            expression=Fn.condition_equals(self.assets_bucket_name_param.value, "")
        )

        self.assets_bucket = aws_s3.CfnBucket(
            self,
            "AssetsBucket",
            access_control="Private",
            bucket_encryption=aws_s3.CfnBucket.BucketEncryptionProperty(
                server_side_encryption_configuration=[
                    aws_s3.CfnBucket.ServerSideEncryptionRuleProperty(
                        server_side_encryption_by_default=aws_s3.CfnBucket.ServerSideEncryptionByDefaultProperty(
                            sse_algorithm="AES256"
                        )
                    )
                ]
            ),
        )
        self.assets_bucket.cfn_options.condition=self.assets_bucket_name_not_exists_condition
        self.assets_bucket.cfn_options.deletion_policy = CfnDeletionPolicy.RETAIN
        self.assets_bucket.cfn_options.update_replace_policy = CfnDeletionPolicy.RETAIN
        self.assets_bucket_arn = Arn.format(
            components=ArnComponents(
                account="",
                region="",
                resource=Token.as_string(
                    Fn.condition_if(
                        self.assets_bucket_name_not_exists_condition.logical_id,
                        self.assets_bucket.ref,
                        self.assets_bucket_name_param.value_as_string
                    )
                ),
                resource_name="*",
                service="s3"
            ),
            stack=self
        )

        # dns
        dns = Dns(self, "Dns")

        ses = Ses(
            self,
            "Ses",
            hosted_zone_name=dns.route_53_hosted_zone_name_param.value_as_string
        )

        # add permissions for s3 bucket to SES instance user
        ses.instance_user.policies.append(
            aws_iam.CfnUser.PolicyProperty(
                policy_document=aws_iam.PolicyDocument(
                    statements=[
                        aws_iam.PolicyStatement(
                            effect=aws_iam.Effect.ALLOW,
                            actions=[
                                "s3:*"
                            ],
                            resources=[ f"{self.assets_bucket_arn}/*" ]
                        ),
                        aws_iam.PolicyStatement(
                            effect=aws_iam.Effect.ALLOW,
                            actions=[
                                "s3:ListBucket"
                            ],
                            resources=[ self.assets_bucket_arn ]
                        )
                    ]
                ),
                policy_name="AllowAssetsBucket"
            )
        )

        # db_secret
        db_secret = DbSecret(
            self,
            "DbSecret"
        )

        # redis
        redis = ElasticacheRedis(
            self,
            "Redis",
            vpc=vpc
        )

        # asg
        with open("mastodon/launch_config_user_data.sh") as f:
            launch_config_user_data = f.read()
        asg = Asg(
            self,
            "Asg",
            default_instance_type = "t3.xlarge",
            secret_arns=[db_secret.secret_arn(), ses.secret_arn()],
            user_data_contents=launch_config_user_data,
            user_data_variables = {
                "DbSecretArn": db_secret.secret_arn(),
                "Hostname": dns.hostname(),
                "HostedZoneName": dns.route_53_hosted_zone_name_param.value_as_string,
                "InstanceSecretName": Aws.STACK_NAME + "/instance/credentials"
            },
            vpc=vpc
        )

        ami_mapping={ "AMI": { "OEAMI": AMI_NAME } }
        for region in generated_ami_ids.keys():
            ami_mapping[region] = { "AMI": generated_ami_ids[region] }
        aws_ami_region_map = CfnMapping(
            self,
            "AWSAMIRegionMap",
            mapping=ami_mapping
        )

        alb = Alb(
            self,
            "Alb",
            asg=asg,
            health_check_path = "/health",
            vpc=vpc
        )

        asg.asg.target_group_arns = [ alb.target_group.ref ]

        redis_ingress = aws_ec2.CfnSecurityGroupIngress(
            self,
            "RedisSgIngress",
            source_security_group_id=asg.sg.ref,
            description="Allow traffic from ASG to Redis",
            from_port=redis.port,
            group_id=redis.elasticache_sg.ref,
            ip_protocol="tcp",
            to_port=redis.port
        )

        db = AuroraPostgresql(
            self,
            "Db",
            db_secret=db_secret,
            vpc=vpc
        )
        asg.asg.node.add_dependency(db.db_primary_instance)
        asg.asg.node.add_dependency(ses.generate_smtp_password_custom_resource)
        db.add_asg_ingress(asg)
        
        dns.add_alb(alb)
